/*****************************************************************************

Copyright (c) 2015, MariaDB Corporation.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Suite 500, Boston, MA 02110-1335 USA

*****************************************************************************/

/**************************************************//**
@file include/fil0fil.h
The low-level file system encryption support functions

Created 04/01/2015 Jan Lindstr√∂m
*******************************************************/

/*******************************************************************//**
Find out whether the page is page encrypted
@return	true if page is page encrypted, false if not */
UNIV_INLINE
bool
fil_page_is_encrypted(
/*==================*/
	const byte *buf)	/*!< in: page */
{
	return(mach_read_from_4(buf+FIL_PAGE_FILE_FLUSH_LSN_OR_KEY_VERSION) != 0);
}

/*******************************************************************//**
Find out whether the page can be decrypted.
The function for decrypting the page should already be executed before this.
@return	PAGE_ENCRYPTION_KEY_MISSING if key provider is available, but key is not available
		0  if decryption should be possible
*/
UNIV_INLINE
ulint
fil_page_encryption_status(
/*===================*/
	const byte *buf,	/*!< in: page */
	ulint space_id)		/*!< in: space_id */
{
	ulint page_type = mach_read_from_2(buf+FIL_PAGE_TYPE);

	if (page_type == FIL_PAGE_TYPE_FSP_HDR) {
		fil_space_crypt_t *crypt_data = fil_space_get_crypt_data(space_id);

		if (crypt_data != NULL) {
			if (!has_encryption_key(crypt_data->keys[0].key_version)) {
				/* accessing table would surely fail, because no key or no key provider available */
				return FIL_ENCRYPTION_KEY_MISSING;
			}
		}
	} else {
		ulint key = mach_read_from_4(buf + FIL_PAGE_FILE_FLUSH_LSN_OR_KEY_VERSION);
		if (!has_encryption_key(key)) {
			return FIL_ENCRYPTION_KEY_MISSING;
		}
	}
	return 0;
}

/******************************************************************
Map used AES method to crypt scheme
@return used AES crypt scheme */
UNIV_INLINE
uint
fil_crypt_get_aes_method(
/*=====================*/
	uint aes_method)
{
	switch (aes_method) {
	case MY_AES_ALGORITHM_NONE:
		return (uint) CRYPT_SCHEME_1_UNENCRYPTED;
		break;
	case MY_AES_ALGORITHM_CTR:
		return (uint) CRYPT_SCHEME_1_CTR;
		break;
	case MY_AES_ALGORITHM_CBC:
		return (uint) CRYPT_SCHEME_1_CBC;
		break;
	default:
		ib_logf(IB_LOG_LEVEL_FATAL,
			"Current AES method %d not supported.\n", aes_method);
		ut_error;
	}

	return (uint) CRYPT_SCHEME_1_UNENCRYPTED;
}

/******************************************************************
Map current aes method
@return AES method */
UNIV_INLINE
uint
fil_crypt_map_aes_method(
/*=====================*/
	uint	aes_method)	/*!< in: AES method */
{
	switch((fil_crypt_method_t)aes_method) {
	case CRYPT_SCHEME_1_CTR:
		return (uint)MY_AES_ALGORITHM_CTR;
		break;
	case CRYPT_SCHEME_1_CBC:
		return (uint)MY_AES_ALGORITHM_CBC;
		break;
	default:
		ib_logf(IB_LOG_LEVEL_FATAL,
			"Current AES method %d not supported.\n", (int)aes_method);
		ut_error;
	}
}
